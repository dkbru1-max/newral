# Интеграция Telegraf для сбора метрик

## Описание задачи
Необходимо встроить в клиентское приложение-агент сборщик телеметрии (например, на основе Telegraf) для автоматического сбора информации о аппаратных ресурсах и состоянии узла. Это позволит в реальном времени мониторить характеристики каждого подключённого узла и отображать их администратору.

## Сбор информации при старте
При запуске агента он должен собрать основную информацию о своём оборудовании:
- **IP-адрес:** внешний (и/или внутренний) сетевой адрес машины.
- **CPU:** модель и тактовая частота процессора, количество ядер/потоков.
- **GPU:** наличие графического ускорителя; если есть – модель GPU, объём видеопамяти, версия драйвера (если доступно).
- **RAM:** общий объём оперативной памяти.
- **Диски:** объём и тип основных дисковых накопителей (HDD/SSD), а также свободное место на них.
- **ОС:** (при необходимости) название и версия операционной системы.

Собранные сведения отправляются на сервер сразу после подключения. Для этого можно расширить протокол регистрации агента: сразу после установления соединения агент делает запрос (например, `POST /agent/register`) с включенной структурой "hardware_info". Сервер сохраняет эти данные в базе, связывая с записью агента.

## Периодические метрики нагрузки
Помимо статических сведений о железе, агент должен периодически передавать динамические метрики:
- Загрузка CPU (например, усреднённая загрузка в % за последние N секунд).
- Использование оперативной памяти (занято/доступно, в мегабайтах или процентах).
- Загрузка GPU (если применимо: процент использования GPU и видеопамяти).
- Сетевая активность (можно отправлять объём переданных/принятых данных или скорость, если это важно для проекта).
- Дисковая активность (произвольный индикатор: например, % нагрузки на диск или скорость I/O).

Для сбора таких метрик с минимальной нагрузкой можно воспользоваться механизмами Telegraf:
- Либо встраивать Telegraf как библиотеку/процесс в Rust-агенте, настроив нужные плагины (CPU, Memory, Disk, GPU, Network).
- Либо использовать существующие crates на Rust (например, `sysinfo`, `heim`) для ручного сбора тех же метрик с желаемой периодичностью.

Агент должен отправлять обновлённые метрики через определённые интервалы (например, каждые 60 секунд). Это может быть реализовано отдельным фоновым асинхронным задачей: сбор данных -> HTTP-запрос к серверу (напр. `PUT /agent/metrics`).

## Хранение и отображение на сервере
На серверной стороне нужно организовать приём и хранение полученных от агентов данных:
- Расширить модель агента в базе данных: добавить поля для статической информации (CPU, GPU, RAM, и т.д.) и, возможно, таблицу для временных метрик. Например, таблица `agent_stats` с колонками `agent_id`, `timestamp`, `cpu_load`, `ram_used`, `gpu_load` и т.д.
- При поступлении нового отчёта метрик обновлять текущие показатели агента (для оперативного отображения) и сохранять запись в историю (для графиков или аудита).
- Интегрировать данные в админ-портал: на странице подробной информации об агенте (см. раздел об админ-портале) показывать:
  - **Характеристики железа:** то, что было собрано при старте (CPU, GPU, RAM, диски, ОС).
  - **Текущие метрики:** последние измеренные значения загрузки CPU, памяти, сети, и пр. Можно отображать численно и/или в виде мини-графиков.
  - **История метрик:** при клике или на отдельной вкладке – графики изменений загрузки за последний час/день (если хранится история).
- При большом количестве агентов стоит подумать о хранилище для метрик (например, InfluxDB, Prometheus). Но на начальном этапе можно обойтись PostgreSQL, если объём данных невелик.

## Реализация в Rust-агенте
- **Выбор инструмента:** Если решено встроить Telegraf, можно запускать его конфигурированным на локальный вывод и перехватывать эти данные. Однако более прямой подход – использовать crates. Crate `sysinfo` позволяет получить CPU load, память и диски. Для GPU, возможно, придётся использовать библиотечные вызовы NVIDIA/CUDA или OpenCL, если нужна детальная инфа.
- **Асинхронность:** Внутри агента следует запускать таймер (async-task или поток) для регулярной отправки метрик, чтобы основная работа (получение и выполнение заданий) не блокировалась.
- **Оптимизация:** Отправлять только необходимые данные. Например, статическую информацию — один раз при подключении или при изменении (изменение оборудования маловероятно во время работы). Динамические — раз в минуту. Избегать слишком частой отправки, чтобы не перегружать сервер.
- **Формат данных:** Использовать легковесный формат (JSON) для передачи метрик. Например, `{ "cpu": 55.0, "ram": 2048, "gpu": 0, "ts": 1681234567890 }`. Сервер на своей стороне может сконвертировать или агрегировать.
- **Логи и отладка:** Добавить логирование: агент должен логировать отправку метрик и любые ошибки (например, если не удалось собрать метрику GPU, выводить предупреждение). Это поможет при тестировании на разных конфигурациях.

## Приватность и согласие
Так как сбор и передача аппаратных данных касаются приватности пользователя, необходимо убедиться, что пользователь дал на это согласие:
- Добавить в текст пользовательского соглашения (EULA) пункт о том, что программа собирает информацию о системе и отправляет её на сервер (см. раздел про EULA).
- Реализовать так, что отправка метрик начинается **только после** принятия пользователем EULA. Если пользователь не согласен, агент не должен ни подключаться к серверу, ни передавать какие-либо данные.
- Обеспечить защиту данных: передавать метрики по защищённому каналу (HTTPS) и хранить их безопасно. Хотя данные не персональные, они описывают систему пользователя, что тоже требует ответственного обращения.

В результате, благодаря интеграции телеметрии, администратор платформы будет обладать актуальной информацией о каждом узле: его потенциале (железо) и текущем состоянии. Это поможет в распределении задач (например, давать тяжёлые задачи узлам с хорошими ресурсами) и в быстром выявлении проблемных узлов (перегрев, перегрузка, нестабильность и т.д.).
