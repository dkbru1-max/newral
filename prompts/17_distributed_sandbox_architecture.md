Используй docs/PROJECT_BRIEF.md и docs/SANDBOX_MVP.md для разработки решения. Цель: спроектировать и реализовать распределённую песочницу для выполнения кода, масштабируемую на множество агентов и сервер, с контролем при помощи ИИ.

1) **Клиентская песочница (Agent Sandbox)**: Развей текущую реализацию песочницы на агенте.
   - Агент должен принимать задачу с произвольным Python-кодом (task.payload) и запускать её в изолированном процессе (как сделано в MVP-песочнице). Убедись, что выполнение происходит в директории-временной «песочнице» с ограниченными ресурсами (CPU/память/время), как реализовано ранее.
   - Подготовь интерфейс для передачи результатов выполнения на сервер: результаты должны включать не только вывод кода, но и метаданные (время выполнения, объём данных, возникшие исключения и пр.), пригодные для дальнейшего анализа на стороне сервера.

2) **Серверная песочница (Server Sandbox)**: Добавь серверный компонент для агрегирования и проверки результатов.
   - Реализуй в составе backend-сервисов новый модуль или отдельный сервис, отвечающий за выполнение кода и проверку результатов на стороне сервера. Например, это может быть часть validator-service или отдельный `sandbox-service`.
   - **Агрегация результатов:** Сделай так, чтобы серверная песочница могла принимать результаты от множества агентов, объединять их и выполнять дополнительную обработку. Например, если 100 агентов прислали частичные вычисления, серверная песочница собирает их в единый итог.
   - **Перепроверка:** Предусмотри возможность запуска полученного от агента кода повторно уже на сервере (в более контролируемой среде, например внутри Docker-контейнера или с усиленными лимитами) для верификации результатов. Это повысит доверие к результатам и обезопасит от недобросовестных агентов.
   - Ограничения безопасности на сервере должны быть еще строже: если возможно, запускай код в изолированном контейнере (Docker, Firecracker или аналог) и с минимальными привилегиями.

3) **Масштабируемость и шардирование**: Обеспечь поддержку разбивки больших задач на части и параллельной обработки.
   - Добавь возможность автоматической нарезки больших объемов данных или задач на подзадачи (shards), которые распределяются между агентами. Например, если задача требует обработать данные из 100 источников, orchestrator разбивает её на 100 задач для агентов.
   - Реализуй механизм сбора этих подзадач: серверная песочница должна ждать результаты от всех шардов и потом агрегировать их (например, суммирование, сортировка, комбинация результатов – в зависимости от задачи). Продумай формат хранения промежуточных результатов (в БД или временном хранилище) и способ их объединения.
   - Убедись, что orchestrator/scheduler умеет отслеживать такие составные задания: все дочерние задачи должны быть связаны с родительской задачей/проектом, и финальный результат формируется после завершения последней дочерней задачи.

4) **Промежуточная проверка с помощью ИИ**: Внедри этап AI-валидации в цикл выполнения задач.
   - Используй модуль ИИ (например, подключаемую модель или сервис) для анализа выполняемого кода и результатов. На этапе запуска песочницы агент может отправлять серверу описание задачи (или ключевые характеристики), и ИИ-модуль решает, нет ли подозрительных действий (например, вредоносных паттернов) – в MVP можно ограничиться простыми эвристиками или логгированием.
   - После получения результатов объединяй их и пропускай через ИИ-проверку: например, ИИ может оценить корректность или аномалии в выходных данных. Если результат выглядит неверным или подозрительным, пометь задачу как требующую ручной проверки или дополнительного запуска.
   - Реализуй аудит-лог: сохраняй историю всех действий песочницы (кто/что запускал, какие файлы создавались, объемы данных, время работы, итоговый статус). Эти данные сохраняй в БД или лог-файлах, чтобы их мог анализировать как ИИ, так и разработчики для отладки и безопасности.

5) **Выходные данные и генерация новых задач**: Сделай так, чтобы результаты распределённой песочницы могли инициировать последующие действия системы.
   - Определи структуру выходных данных/метрик после агрегации: например, процент успешных подзадач, ключевые метрики результата, выявленные паттерны и т.д.
   - На базе этих выходных метрик предусмотри автоматическое создание последующих команд или задач более высокого уровня. То есть реализуй примитивную цепочку задач: после завершения одного этапа (chain step) система анализирует итог и формирует новую задачу/набор задач для дальнейшей обработки. (Пример: после агрегирования данных сервер решает запустить задачу по их отчетной визуализации или по очистке/фильтрации).
   - Внедри этот механизм в scheduler-service или отдельном модуле “planner”: он должен уметь на основании результата (и при необходимости с помощью ИИ) решать, нужно ли ставить новые задачи в очередь. На MVP можно ограничиться жестко запрограммированным условием или простым правилом (например, если сумма значений превышает X – создать задачу Y).

6) **Документация**: Оформи результаты и архитектуру распределённой песочницы в документации.
   - Добавь или обнови раздел docs/SANDBOX_DISTRIBUTED.md (либо расширь существующий SANDBOX_MVP.md) с описанием новой архитектуры: разница между клиентской и серверной песочницей, как происходит разбиение задач, роль ИИ в проверке, как реализована цепочка задач.
   - Объясни, какие ограничения и допущения остались (например, нет полной изоляции или ручной настройки для ИИ), и наметь планы по дальнейшему усилению безопасности и масштабирования.
